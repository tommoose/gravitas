<!--
    TODO: add clouds, fix drag model
-->
<html>
<head><meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
	
	<meta content="width=800, initial-scale=1" name="viewport" />
	<title></title>
	<script>
	</script>
</head>
<body style="margin: 0">
<div id="underlay" onscroll="OnScrollFunction()" style="width: 100%; height: 100%; overflow:hidden; z-index: -1; position: absolute; top: 0; background-color: #292929">
    <canvas id="canvas" style="margin: 0; padding: 0"></canvas>
</div>
<script>
    var raf, running = false;
    var canvas = document.getElementById('canvas');
    var ctx = canvas.getContext('2d',{alpha: false});
    ctx.canvas.width  = document.getElementById("underlay").offsetWidth;
    ctx.canvas.height = document.getElementById("underlay").offsetHeight;

    function offset(x1, y1, x2, y2) {
        return point(x2-x1, y2-y1);
    }

    function distance(x1, y1, x2, y2) {
        return Math.sqrt(Math.abs(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)));
    }

    function is_point_in_view(x, y, padding) {
        if (padding == null)
            padding = 0;

        var view_size = point(ctx.canvas.width * zoom, ctx.canvas.height * zoom);

        if (x > craft.pos.x - (view_size.x / 2) - padding && x < craft.pos.x + (view_size.x / 2) + padding)
            if (y > craft.pos.y - (view_size.y / 2) - padding && y < craft.pos.y + (view_size.y / 2) + padding)
                return true;

        return false;
    }

    function centre(min_x, min_y, max_x, max_y) {
        return point(min_x + (max_x - min_x) / 2, min_y + (max_y - min_y) / 2);
    }

    function rotate_point(px, py, ox, oy, angle) {
        return point(
            Math.cos(angle) * (px - ox) - Math.sin(angle) * (py - oy) + ox,
            Math.sin(angle) * (px - ox) + Math.cos(angle) * (py - oy) + oy
        );
    }

    function roundTo(input, num) {
        var resto = input%num;
        if (resto <= (num/2)) { 
            return input-resto;
        } else {
            return input+num-resto;
        }
    }
		
    function polar_to_point(radius, angle) {
        return point(
            radius * Math.cos(angle),
            radius * Math.sin(angle)
        );
    }
    
    function point_to_polar(x, y) {
        return polar(
            Math.atan2(y,x),
            Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)),
        );
    }
    
    var point = function(x, y) {
        return {
            x: x,
            y: y
        }
    }

    var polar = function(angle, radius) {
        return {
            radius: radius,
            angle: angle,
        }
    }

    var well = function(pos, g){
        return {
            pos: pos,
            g: g
        }
    };

    function start() {
        lastTime = new Date();
        running = true;
        animate();
    }

    document.addEventListener("keydown", function(e) {

        if (e.which == 71) {        // g
            gravity_disabled = !gravity_disabled;
            e.preventDefault();
        } else if (e.which == 13) {   // enter
            if (!running) {
                start();
            } else {
                // Reset
                reset();
            }
            e.preventDefault();
        } else if (e.which == 20) {   // Caps
            isAuto = e.getModifierState("CapsLock");
        } else if (e.which == 32) {   // space
            if (!running)
                start();
            craft.throttle = 100;
            e.preventDefault();
        } else if (e.which == 37) {   // left
            craft.rcs_throttle = -100;
            e.preventDefault();
        } else if (e.which == 39) {   // right
            craft.rcs_throttle = 100;
            e.preventDefault();
        } else if (e.which == 40) {   // down
            craft.rotational_velocity = 0;  // stability control
            e.preventDefault();
        } else if (e.which >= 49 && e.which <= 57) {   // 1-9
            if (!running) start();
            craft.throttle = (e.which - 48) * 10;
            e.preventDefault();
        } else if (e.which == 48) {   // 0
            if (!running) start();
            craft.throttle = 100;
            e.preventDefault();
        } else if (e.which == 65) {   // A
            autopilot.movement.x = -1;  // Move left
            e.preventDefault();
        } else if (e.which == 68) {   // D
            autopilot.movement.x = 1;  // Move right
            e.preventDefault();
        } else if (e.which == 79) {   // O
            // Zoom:
            if (zoom == 1)
                zoom = 25;
            else
                zoom = 1;
            if (!running)
                redraw();
            e.preventDefault();
        } else if (e.which == 83) {   // S
            autopilot.movement.y = 1;  // Move down
            e.preventDefault();
        } else if (e.which == 87) {   // W
            autopilot.movement.y = -1;  // Move up
            e.preventDefault();
        } else if (e.which == 88) {   // X
            if (!running) start();
            craft.throttle = 0;
            e.preventDefault();
        } else if (e.which == 90) {   // Z
            if (!running) start();
            craft.throttle = 100;
            e.preventDefault();
        } else if (e.which == 84) {   // T
            trails_on = !trails_on;
            e.preventDefault();
        } else if (e.which == 192) {  // `~
            craft.throttle = 0;
            if (!e.getModifierState("Meta"))
                e.preventDefault();
        } else if (e.which == 190) {   // .
            warp = 1000;
            e.preventDefault();
        } else if (e.which == 191) {  // question mark
            show_help = !show_help
            redraw();
            e.preventDefault();
        } else {    // everything else
            if (show_help)
                console.log("Key" + e.which);
        }
        
    });

    document.addEventListener("keyup", function(e) {
        if (e.which == 32) { // space
            craft.throttle = 0;
            e.preventDefault();
        } else if (e.which == 20) {   // Caps
            isAuto = e.getModifierState("CapsLock");
        }
        else if (e.which == 37) {   //left
            craft.rcs_throttle = 0;
            e.preventDefault();
        }
        else if (e.which == 39) {   //right
            craft.rcs_throttle = 0;
            e.preventDefault();
        }
    });


    window.addEventListener('scroll', function(e) {
        e.preventDefault();
        //console.log(e);
    });

    window.addEventListener('wheel', function(e) {
        e.preventDefault();
        if (e.shiftKey) {
            // warp
            warp += e.deltaY * 0.001 * warp
            if (warp <= 0.01)
                warp = 0.01;
            
            if (!running)
                redraw();

        } else {
            // zoom
            zoom += e.deltaY * 0.001 * zoom
            if (zoom <= 0.01)
                zoom = 0.01;
            
            if (!running)
                redraw();
        }
    });
		
    var lastTime, timeSinceLastFrame = 0;
    function animate() {
        if (running) {
            if (!check_win()) {
                redraw();
                raf = window.requestAnimationFrame(animate);
                var now = new Date();
                timeSinceLastFrame = now - lastTime;
                lastTime = now;
            } else {
                draw_win();
            }
        }
    }

    // particulars
    var craft, planet, gate, clouds = {0:[],1:[],2:[]}, maxClouds = { 0:24000, 1:16000, 2: 6000}, exhaust = [];
    var gravity_on = true, gravity_disabled = false, trails_on = false, draw_dashes = false;
    var show_help = false;
    var message = "", message_start = null, k_message_timeout = 3000;
    var warp = 1000, zoom = 3, zoomlimit_clouds = 800;
    var isAuto = false, autopilot = { altitude: 200, movement: point(0,0) };

    reset();

    function reset() {
        running = false;

        gravity_on = true;
        display_help = false;
        warp = 1000;
        zoom = 3;
        
        craft = setupCraft();
        planet = setupPlanet();
        //gate = setupGate();

        setup_clouds();
        
        redraw();
    }

    function setupCraft() {
        return {
            pos: point(0, setupPlanet().radius * -1 - 55), 
            size: point(10,110),//point(30, 30),
            mass: 2970000,//100,
            dry_mass: 20,
            impulse: point(0,0),
            delta_vee: point(0,0),
            velocity: point(0,0),
            rotational_velocity: 0,
            rotation_velocity_max: 100,
            color: "rgb(255,255,255)",
            attitude: 0,
            throttle: 0,
            thrust: 50000000,//36000000,//150000,
            rcs_throttle: 0,
            rcs_thrust: 300000,
            drag_coefficient: 0.2,
            drag: point(0,0),
        }
    }

    function setupPlanet() {
        return {
            pos: point(0, 0), 
            g: 20,
            mass: 5.972 * Math.pow(10,24),
            velocity: point(0,0),
            radius: 6371000,
            color: "rgb(60,120,90)",
        }
    }

    function setupGate() {
        return {
            pos: point(ctx.canvas.width * 1 / 4, 0),
            radius: 30,
            mass: 0,
            impulse: point(0,0),
            delta_vee: point(0,0),
            velocity: point(0, 0),
            color: "rgb(40,40,255)",
        }
    }

    function setup_clouds() {
        while (clouds[0].length < maxClouds[0])
            clouds[0].push(create_cloud_cumulus());

        while (clouds[1].length < maxClouds[1])
            clouds[1].push(create_cloud_altocumulus());

        while (clouds[2].length < maxClouds[2])
            clouds[2].push(create_cloud_cirrus());
    }

    function redraw() {
        ctx.setTransform(1,0,0,1,0,0);//reset the transform matrix as it is cumulative
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

        ctx.translate(ctx.canvas.width * 0.5, ctx.canvas.height * 0.5);
        ctx.transform(1/zoom, 0, 0, 1/zoom, 0, 0 );
        
        if (running) {

            if (gravity_on && !gravity_disabled) {
                apply_gravity(craft, planet);
                if (gate != null)
                    apply_gravity(gate, planet);

            }


            apply_thrust(craft);
            apply_drag(craft);

            if (isAuto)
                apply_autopilot(autopilot, craft, planet);

            update_velocity(craft, timeSinceLastFrame);
            check_land();

            apply_rcs(craft);
            update_rotational_velocity(craft);
        }

        ctx.translate(-1 * craft.pos.x, -1 * craft.pos.y);

        draw_planet(planet);

        if (zoom < zoomlimit_clouds * 2)
        {
            draw_clouds();
            draw_exhaust(craft);
        }



        //draw_gate(gate);

        draw_ghost(craft);

        draw_craft(craft);
        
        // HUD
        if (!running)
            draw_title();

        if (show_help) {
            draw_help();
            draw_stats();
        }
        
        draw_hud();

        // if (message != "" && (new Date() - message_start) <= k_message_timeout)
        //     draw_text([message], "CC");

        craft.impulse = point(0,0);   // reset
    }

    function apply_autopilot(a, c, p) {
        var throttletime = 3;

        // Altitude
        var altitude = distance(p.pos.x, p.pos.y, c.pos.x, c.pos.y) - p.radius - c.size.y / 2;
        var delta_vee = distance(0, 0, c.velocity.x, c.velocity.y);
        var total_impulse = c.thrust / c.mass;
        var radialVelocity = point_to_polar(craft.velocity.x, craft.velocity.y);
        var distToTarget = (a.altitude - altitude);
        var timeToTarget = Math.abs(distToTarget) / radialVelocity.radius;
        var timeToZero = delta_vee / total_impulse;

        var aboveTarget = distToTarget < 0;
        var tooSlow = timeToTarget > timeToZero;        // TODO: calc velocity/acc
        var movingAwayFromPlanet = radialVelocity.angle < 0

        var status = aboveTarget ? "above" : "below";
        status += tooSlow ? " slow" : " fast";
        status += movingAwayFromPlanet ? " up" : " down";

        console.log(status);

        if (distToTarget < 0) {
            // Above
            if (movingAwayFromPlanet)
                // Moving upwards
                c.throttle = Math.max(c.throttle - 10, 0); // Throttle down
            else
                // Moving downwards
                if (tooSlow)
                    // Too slow
                    c.throttle = Math.max(c.throttle - 10, 0); // Throttle down
                else
                    // Too quick
                    c.throttle = Math.min(c.throttle + 10, 100); // Throttle up

        } else {
            // Below
            if (movingAwayFromPlanet)
                // Moving upwards
                if (tooSlow)
                    // Too slow
                    c.throttle = Math.min(c.throttle + 10, 100); // Throttle up
                else
                    // Too quick
                    c.throttle = Math.max(c.throttle - 10, 0); // Throttle down
            else
                // Moving downwards
                c.throttle = Math.min(c.throttle + 10, 100); // Throttle up
        }
        
    }

    function calculate_gravity(obj, well) {
        if (gravity_disabled || !gravity_on)
            return 0;

        var rel_pos = offset(obj.pos.x, obj.pos.y, well.pos.x, well.pos.y);

        var dist = Math.sqrt(Math.pow(rel_pos.x, 2) + Math.pow(rel_pos.y, 2));

        // F = G*((m sub 1*m sub 2)/r^2)
        return (6.67*Math.pow(10,-11)) * (obj.mass * well.mass) / Math.pow(dist, 2);
    }

    function apply_gravity(obj, well) {
        var rel_pos = offset(obj.pos.x, obj.pos.y, well.pos.x, well.pos.y);
        var dist = Math.sqrt(Math.pow(rel_pos.x, 2) + Math.pow(rel_pos.y, 2));
        var F = (6.67*Math.pow(10,-11)) * (obj.mass * well.mass) / Math.pow(dist, 2);

        //console.log(dist)
        if (F == 0)
            running = false;

        obj.impulse.x += F * rel_pos.x / dist;
        obj.impulse.y += F * rel_pos.y / dist;
    }

    function apply_thrust(c) {
        if (c.throttle > 0)
        {
            var thrust_x = c.thrust * Math.cos(c.attitude + Math.PI / 2) * c.throttle / 100;
            var thrust_y = c.thrust * Math.sin(c.attitude + Math.PI / 2) * c.throttle / 100;
            
            //console.log("Thrust: " + thrust_x + ", " + thrust_y);

            // atmosphere


            c.impulse.x -= thrust_x;
            c.impulse.y -= thrust_y;
        }
    }

    function apply_drag(c) {
        
        //var h = distance(c.pos.x, c.pos.y, planet.pos.x, planet.pos.y) - planet.radius * 0.3048; // to feet

        var T;
        var atmos = get_atmosphere(c);

        var drag_x = c.drag_coefficient * c.size.x * .5 * atmos.density * Math.pow(c.velocity.x, 2);
        var drag_y = c.drag_coefficient * c.size.x * .5 * atmos.density * Math.pow(c.velocity.y, 2);

        c.drag = point(drag_x, drag_y);
    }

    function get_atmosphere(c) {
        var h = distance(c.pos.x, c.pos.y, planet.pos.x, planet.pos.y) - planet.radius; // in meters
        //var f = h * 3.2808399; // to feet
        var atmos = {
            zone: 0,
            altitude: h,
            temperature: 0,
            pressure: 0,
            density: 0,
            };


        if (h <= 11000) {
            // Troposphere
            atmos.zone = 0;
            atmos.temperature = 15.04 - 0.00649 * h;
            atmos.pressure = 101.29 * Math.pow((atmos.temperature + 273.1) / 288.08, 5.256);
        } else if (h < 25000) {
            // Lower stratosphere
            atmos.zone = 1;
            atmos.temperature = -56.46;
            atmos.pressure = 22.65 * Math.exp(1.73 - 0.000157 * h);
        } else {
            // Upper stratosphere
            atmos.zone = 2;
            atmos.temperature = -131.21 + 0.00299 * h;
            atmos.pressure = 2.488 * Math.pow((atmos.temperature + 273.1) / 216.6, -11.388);
        }

        atmos.density = atmos.pressure / (0.2869 * (atmos.temperature + 273.1));

        return atmos;
    }

    function apply_rcs(c) {
        if (c.rcs_throttle != 0)
        {
            c.rotational_velocity += c.rcs_thrust / c.mass * c.rcs_throttle / 100;
            if (Math.abs(c.rotational_velocity) > c.rotation_velocity_max)
                c.rotational_velocity = c.rotation_velocity_max * (c.rotational_velocity / Math.abs(c.rotational_velocity));
        }
    }

    function update_velocity(obj, timeSpan) {
        // drag (N)
        if (obj.velocity.x > 0)
            obj.impulse.x -= Math.abs(obj.drag.x);
        else 
            obj.impulse.x += Math.abs(obj.drag.x);

        if (obj.velocity.y > 0)
            obj.impulse.y -= Math.abs(obj.drag.y);
        else 
            obj.impulse.y += Math.abs(obj.drag.y);

        // a (m/s/s)
        var a_x = obj.impulse.x / obj.mass;
        var a_y = obj.impulse.y / obj.mass;

        // v (m/s) = v + a * t
        obj.velocity.x += a_x * timeSpan / warp;
        obj.velocity.y += a_y * timeSpan / warp;
        
        // pos (m) = v * t
        var d_x = obj.velocity.x * timeSpan / warp;
        var d_y = obj.velocity.y * timeSpan / warp;

        obj.pos.x += d_x;
        obj.pos.y += d_y;
    }

    function update_rotational_velocity(c) {
        c.attitude += c.rotational_velocity * timeSinceLastFrame / warp;
    }

    function draw_craft(c) {
        ctx.save();

        ctx.beginPath();

        var width = c.size.x;
        var height = c.size.y;

        var points = [];
        
        points.push(point(Math.floor(c.pos.x - width / 2), Math.floor(c.pos.y - height / 2)));  // NW
        
        points.push(point(Math.floor(c.pos.x),Math.floor(c.pos.y - height)));   // N
        
        points.push(point(Math.floor(c.pos.x + width / 2),Math.floor(c.pos.y - height / 2)));   // NE
        points.push(point(Math.floor(c.pos.x + width / 2),Math.floor(c.pos.y + height / 2)));   // SE

        points.push(point(Math.floor(c.pos.x - width / 2),Math.floor(c.pos.y + height / 2)));   // SW

        // attitude
        for (var i = 0; i < points.length; i++) {
            var p = points[i],
                newpoint = rotate_point(p.x, p.y, c.pos.x, c.pos.y, c.attitude);
            //points[i] = newpoint;
            
            // draw points
            if (i == 0)
                ctx.moveTo(newpoint.x, newpoint.y);
            else
                ctx.lineTo(newpoint.x, newpoint.y);
        }

        // reset for flames
        points = [];        

        ctx.fillStyle = c.color;
        ctx.fill();

        if (c.throttle > 0)
        {
            ctx.beginPath();
            var flameLength = height / 2 * c.throttle / 100;

            points.push(point(Math.floor(c.pos.x + width / 2),Math.floor(c.pos.y + height / 2)));   // SE

            points.push(point(Math.floor(c.pos.x + width * 2 / 6),Math.floor(c.pos.y + height / 2 + flameLength)));       // Flames 1 outer
            points.push(point(Math.floor(c.pos.x + width * 1 / 6),Math.floor(c.pos.y + height / 2)));   // Flames 2 inner
            points.push(point(Math.floor(c.pos.x                ),Math.floor(c.pos.y + height / 2 + flameLength)));       // Flames 3 outer
            points.push(point(Math.floor(c.pos.x - width * 1 / 6),Math.floor(c.pos.y + height / 2)));   // Flames 4 inner
            points.push(point(Math.floor(c.pos.x - width * 2 / 6),Math.floor(c.pos.y + height / 2 + flameLength)));       // Flames 5 outer
        
            points.push(point(Math.floor(c.pos.x - width / 2),Math.floor(c.pos.y + height / 2)));   // SW


            // attitude
            for (var i = 0; i < points.length; i++) {
                var p = points[i],
                    newpoint = rotate_point(p.x, p.y, c.pos.x, c.pos.y, c.attitude);
                //points[i] = newpoint;
                
                // draw points
                if (i == 0)
                    ctx.moveTo(newpoint.x, newpoint.y);
                else
                    ctx.lineTo(newpoint.x, newpoint.y);
            }
            
            //ctx.fillStyle = "rgba(155,188,255, 0.5)"; // blue
            ctx.fillStyle = "rgba(250,220,58,0.8)"; // yellow
            ctx.fill();
        }

        ctx.restore();
    }

    function draw_ghost(c) {
        var t_max = 5000, points_max = 10000;
        var increment = 100; // ms
        var points = 0;
        var c_ghost = jsonCopy(c);
        var apoapsis = point(0,0), periapsis = point(0,0);
        var ap_found = false, per_found = false;

        ctx.strokeStyle = "rgba(250,220,58,0.8)"; // yellow
        ctx.lineWidth = 1 * zoom;
        ctx.beginPath();

        var current_dir = 0;

        while (points < points_max) {

            // var vel = c_ghost.velocity;

            ctx.lineTo(
                c_ghost.pos.x,
                c_ghost.pos.y);

            var pos_prev = c_ghost.pos;
            var pol_prev = point_to_polar(c_ghost.pos.x, c_ghost.pos.y)

            //if (!is_point_in_view(c_ghost.pos.x, c_ghost.pos.y)) break;
            //if (is_point_in_planet(c_ghost.pos, planet)) break;
            
            c_ghost.impulse = point(0,0);   // reset
            // update_velocity will change position, let's recalculate the drag and gravity
            apply_drag(c_ghost);
            apply_gravity(c_ghost, planet);
            // apply_thrust(c_ghost);


            update_velocity(c_ghost, increment);

            var pol_next = point_to_polar(c_ghost.pos.x, c_ghost.pos.y)
            var infl = pol_next.radius - pol_prev.radius;

            if (current_dir == 0) {
                current_dir = infl;
            }
            else if (infl > 0 && current_dir < 0 && !per_found) {
                // found next - periapsis
                periapsis = pos_prev;
                per_found = true;
                ctx.arc(periapsis.x, periapsis.y, c_ghost.size.x * zoom, 0, Math.PI * 2);
            }
            else if (infl < 0 && current_dir > 0 && !ap_found) {
                // found next - apoapsis
                apoapsis = pos_prev;
                ap_found = true;
                ctx.arc(apoapsis.x, apoapsis.y, c_ghost.size.x * zoom, 0, Math.PI * 2);
            }

            points += 1;
        }

        ctx.stroke();
        
        // ctx.beginPath();
        // ctx.strokeStyle = "rgba(250,220,58,0.8)"; // yellow
        // ctx.arc(apoapsis.x, apoapsis.y, c.size.x * zoom, 0, 2*Math.PI);
        // ctx.arc(periapsis.x, periapsis.y, c.size.x * zoom, 0, 2*Math.PI);
        // ctx.stroke();

    }
    
    function jsonCopy(src) {
        return JSON.parse(JSON.stringify(src));
    }

    function rotate_points(points) {
        
    }

    function create_cloud_cumulus() {
        return create_cloud(
            maxClouds[0],   // Max clouds                           (density)
            0,              // Zone
            3/2,            // Cloud spacing jitter                 (ratio to spacing_angle)
            2000,           // Altitude                             (low)
            1/256,            // Altitude jitter                      (ratio to circle_radius_default)
            planet.radius,  // Planet radius
            1/22000,        // Circle radius default                (ratio to planet_radius)
            4/2,            // Circle radius jitter                 (ratio to circle_radius_default)
            1/3,            // Circle horizontal position jitter    (ratio to circle_radius_default)
            4,
        );
    }
    function create_cloud_altocumulus() {
        return create_cloud(
            maxClouds[1],   // Max clouds                           (density)
            1,              // Zone
            1/2,            // Cloud spacing jitter                 (ratio to spacing_angle)
            6000,           // Altitude                             (medium)
            1/64,            // Altitude jitter                      (ratio to circle_radius_default)
            planet.radius,  // Planet radius
            1/26000,        // Circle radius default                (ratio to planet_radius)
            8/2,            // Circle radius jitter                 (ratio to circle_radius_default)
            1/12,           // Circle horizontal position jitter    (ratio to circle_radius_default)
            8,
        );
    }
    function create_cloud_cirrus() {
        return create_cloud(
            maxClouds[2],   // Max clouds                           (density)
            2,              // Zone
            0,            // Cloud spacing jitter                 (ratio to spacing_angle)
            11000,           // Altitude                            (high)
            0,            // Altitude jitter                      (ratio to circle_radius_default)
            planet.radius,  // Planet radius
            1/24000,        // Circle radius default                (ratio to planet_radius)
            1/1,            // Circle radius jitter                 (ratio to circle_radius_default)
            1/32,             // Circle horizontal position jitter    (ratio to circle_radius_default)
            8
        );
    }

    function create_cloud(
        maxClouds, 
        zone,
        cloud_spacing_jitter, 
        altitude, 
        altitude_jitter,
        planet_radius,
        circle_radius_default, 
        circle_radius_jitter, 
        circle_horizontal_position_jitter,
        circles_per_cloud,
        ) {

        var spacing_angle = 2 * Math.PI / maxClouds;
        
        // resolve ratios
        cloud_spacing_jitter = cloud_spacing_jitter * spacing_angle;
        circle_radius_default = circle_radius_default * planet_radius
        altitude_jitter = altitude_jitter * circle_radius_default;
        circle_radius_jitter = circle_radius_jitter * circle_radius_default;
        circle_horizontal_position_jitter = circle_horizontal_position_jitter * circle_radius_default;

        var altitude_radius = planet_radius + altitude;
        
        var cloud = {
            circles: [],
            origin_angle: -1 * Math.PI / 2 + (Math.random() - 0.5) * cloud_spacing_jitter,
            spacing_angle: spacing_angle,   // static for zone, for spreading out at render
            zone: zone,
        };

        var altitude_jitter_val = Math.random();  // generate altitude jitter once for all circles

        var horiz_jitter = circle_radius_default * circle_horizontal_position_jitter;

        for (var i = 0; i < circles_per_cloud; i++) {
            var radius_jitter_val = Math.random();
            var c = {
                origin: polar(
                    (Math.random() - 0.5) * horiz_jitter * (i - 2), 
                    altitude_radius + (radius_jitter_val * altitude_jitter * circle_radius_default)
                ),
                radius: circle_radius_default + radius_jitter_val * circle_radius_jitter,
            }
            cloud.circles.push(c);
        }

        return cloud;
    }

    function draw_clouds() {

        ctx.save();
        ctx.fillStyle = "rgba(255,255,255,0.4)";

        var angle_start = {
            0: 0,
            1: 0,
            2: 0,
        }, angle_end = {
            0: 2 * Math.PI,
            1: 2 * Math.PI,
            2: 2 * Math.PI,
        };

        for (var z = 0; z < 3; z++) {
            for (var i = 0; i < clouds[z].length; i++) {
                for (var c = 0; c < clouds[z][i].circles.length; c++) {
                    if (zoom > zoomlimit_clouds && c % 2 == 0)
                        continue;

                    var centre_polar = polar(
                        (clouds[z][i].spacing_angle * (i - (clouds[z].length / 2))) + clouds[z][i].origin_angle + clouds[z][i].circles[c].origin.angle,
                        clouds[z][i].circles[c].origin.radius, 
                    )

                    var centre_point = polar_to_point(
                        centre_polar.radius,
                        centre_polar.angle
                    );

                    var circle_radius = clouds[z][i].circles[c].radius;
                    //var relative_position = offset(planet.pos.x, planet.pos.y, clouds[z][i].circles[c].origin.x, clouds[z][i].circles[c].origin.y);
                    var is_circle_in_view = is_point_in_view(centre_point.x, centre_point.y, circle_radius);
                    if (is_circle_in_view) {

                        //var angle = Math.atan2(centre_point.y, relative_position.x);
                        var draw_circle = z > 0;

                        if (zoom > zoomlimit_clouds / 8) {
                            // Solid circle
                            ctx.beginPath();
                            ctx.arc(
                                centre_point.x,
                                centre_point.y,// + planet.radius * Math.cos(Math.atan(clouds[z][i].circles[c].origin.x)), 
                                clouds[z][i].circles[c].radius * 0.75, 
                                angle_start[z],
                                angle_end[z]);
                            ctx.fill();
                        } else {
                            // Gradient

                            var gradient_radius = circle_radius * 0.75; // cloud solidity
                            if (z == 2)
                                gradient_radius = circle_radius * 0.25;

                            var gradient = ctx.createRadialGradient(
                                centre_point.x, centre_point.y, gradient_radius, 
                                centre_point.x, centre_point.y, circle_radius
                            );

                            gradient.addColorStop(0, 'rgba(255,255,255,0.4)');
                            gradient.addColorStop(1, 'rgba(255,255,255,0)');
                            ctx.fillStyle = gradient;

                            var box_height = circle_radius * 2;

                            var bounds_origin = point(
                                centre_point.x - circle_radius, 
                                centre_point.y - circle_radius, 
                            );

                            // rotate_point(
                            //     bounds_origin.x, bounds_origin.y,
                            //     centre_point.x, centre_point.y,
                            //     centre_polar.angle
                            // );
                            
                            ctx.fillRect(
                                bounds_origin.x,
                                bounds_origin.y,
                                2 * circle_radius, 
                                box_height
                            );
                        }
                    }
                }
            }
        }
        ctx.restore();
    }

    function draw_exhaust(c) {
        var engine_location = point(
            c.pos.x - c.size.y / 2 * Math.sin(c.attitude),
            c.pos.y + c.size.y / 2 * Math.cos(c.attitude)
            );
        
        var exhaust_velocity = 1800 , default_radius = c.size.x / 3, expansion_rate = 8000, max_dist = 2000;

        ctx.save();

        var atmosphere = get_atmosphere(c);

        for (var e = 0; e < exhaust.length; e++) {
            var dist = distance(
                engine_location.x, engine_location.y, 
                exhaust[e].centre.x, exhaust[e].centre.y
            );  // from engines

            if (dist > max_dist)
            {
                dist = 0;
                if (e < c.throttle && Math.floor(atmosphere.pressure) > 0 && exhaust[e].radius <= max_dist)
                {
                    exhaust[e] = {centre: engine_location, radius: default_radius};   // reset
                } else {
                    exhaust.splice(e, 1);   // reset
                    continue;
                }
            }

            if (exhaust[e].radius >= 0) {
                ctx.beginPath();
                ctx.arc(
                    exhaust[e].centre.x,
                    exhaust[e].centre.y,
                    exhaust[e].radius * 100 / Math.floor(atmosphere.pressure),
                    0,
                    2 * Math.PI);
                ctx.fillStyle = "rgba(255,255,255," + 0.1 / 100 * atmosphere.pressure + ")";
                ctx.fill();

                // translate point for movement (minus craft velocity)
                var jitter = dist / max_dist * Math.PI  * (Math.random() - 0.5);
                exhaust[e].centre = point(
                    exhaust[e].centre.x + (craft.velocity.x / exhaust[e].radius * timeSinceLastFrame / warp) - (exhaust[e].velocity * Math.random() * timeSinceLastFrame / warp) * Math.sin(exhaust[e].angle + jitter),
                    exhaust[e].centre.y + (craft.velocity.y / exhaust[e].radius * timeSinceLastFrame / warp) + (exhaust[e].velocity * Math.random() * timeSinceLastFrame / warp) * Math.cos(exhaust[e].angle + jitter)
                )
                
                // Increase size as it gets further away
                exhaust[e].radius += expansion_rate * (dist / max_dist / 2 ) * (Math.random() / 5) * timeSinceLastFrame / warp;
            }
        }

        if (Math.floor(atmosphere.pressure) > 0 && c.throttle > 0)
                exhaust[exhaust.length] = {centre: engine_location, radius: default_radius, angle: c.attitude, velocity: exhaust_velocity};   // add exhaust

        ctx.restore()
    }

    function draw_text(lines, location) {
        var 
            font = "monospace"
            fontsize = 14,
            line = 0,
            lineheight = fontsize * -1.25,
            padding = point(0,0);

        // SE
        var origin = point(
            (ctx.canvas.width / 2), 
            (ctx.canvas.height / 2)
        );

        // SE styles
        ctx.textAlign = "right";

        // Corners
        if (location[0] == "N")
        {
            origin.y = origin.y * -1;
            lineheight = lineheight * -1;
            padding = point(padding.x, lineheight);
        }
        else if (location[0] == "C") {
            origin.y = 0;
        } else {
            padding = point(padding.x, lineheight)
        }
        
        if (location[1] == "W")
        {
            origin.x = origin.x * -1;
            ctx.textAlign = "left";
            padding = point(lineheight, padding.y)
        }
        else if (location[1] == "C")
        {
            origin.x = 0;
            ctx.textAlign = "center";
        } else {
            padding = point(lineheight * -2, padding.y);
        }

        // Padding
        origin.x += padding.x;
        origin.y += padding.y;

        // Title styles
        if (location == "CC") {
            fontsize = 48;
            lineheight = 48 * 1.25;
            font = "bold " + fontsize * zoom + "px Garamond, georgia, serif";
        } else {
            font = fontsize * zoom + "px monospace";
        }

        // Transform
        origin.x = origin.x * zoom;
        origin.y = origin.y * zoom;
        lineheight = lineheight * zoom;

        // Translate
        origin.x += craft.pos.x;
        origin.y += craft.pos.y;

        ctx.save();

        ctx.fillStyle = "#ffffff";
        ctx.font = font;

        for (line = 0; line < lines.length; line++) {
            ctx.fillText(lines[line], origin.x, origin.y + line * lineheight);
        }

        ctx.restore();
    }

    function draw_title() {
        draw_text(["Gravitas"], "CC");
        draw_text([
            "Press [Space] to Start",
            "Press [?] for options"
            ], "SC");
    }

    function draw_help() {
        draw_text([
            "[?]                Toggle help", 
            "[Enter]            Start/Reset", 
            "[g]                Toggle gravity", 
            "[<--/-->]          Turn", 
            "[Down]             Stop rotation", 
            "[Space]            Thrust", 
            "[Z/X]              Full/Zero Throttle",
            "[Scroll]           Zoom",
            "[Shift-Scroll]     Time warp"
        ], "NW");
    }

    function draw_win() {
        ctx.save();
        ctx.fillStyle = "#ffffff";
        ctx.textAlign = "center";
        ctx.font = "bold " + 48 * zoom + "px Garamond, georgia, serif";
        ctx.fillText("WIN!", craft.pos.x, craft.pos.y + craft.size.y * 1.5);
        ctx.restore();
    }

    function draw_stats() {
        var atmos = get_atmosphere(craft);
        var extra_length = Math.abs(Math.round(craft.size.y / 2 * Math.cos(relative_angle()), 2));

        draw_text([
            "Mass: " + Math.round(craft.mass) + "kg",
            "Gravity: " + (gravity_disabled ? "[disabled]" : (gravity_on ? Math.round(calculate_gravity(craft, planet)) + "N" : "[Landed]")),

            "Altitude: " + Math.round(atmos.altitude - extra_length) + "m",
            "Zone: " + atmos.zone,
            "Pressure: " + Math.round(atmos.pressure) + "KPa",
            "Density: " + Math.round(atmos.density) + "kg/m3",

            "X: " + Math.round(craft.pos.x) + "m",
            "Y: " + Math.round(craft.pos.y) + "m",

            "Fx: " + Math.round(craft.impulse.x) + "N",
            "Fy: " + Math.round(craft.impulse.y) + "N",

            "Vx: " + Math.round(craft.velocity.x) + "m/s",
            "Vy: " + Math.round(craft.velocity.y) + "m/s",

            "Dx: " + Math.round(craft.drag.x) + "N",
            "Dy: " + Math.round(craft.drag.y) + "N",

            "Warp: " + warp,

            "RelAngle: " + (relative_angle() / Math.PI).toPrecision(2) + " PI",
            "Extra Length: " + extra_length,

            "Autopilot: " + isAuto,
            "Throttle: " + craft.throttle,

            "FPS: " + (1000 / timeSinceLastFrame).toPrecision(3),
        ], "NE");
    }

    function draw_hud() {
        ctx.save();

        var radius = roundTo((ctx.canvas.width / 25) * zoom, 1);

        // SE
        var origin = point(
            (ctx.canvas.width / 2) * zoom, 
            (ctx.canvas.height / 2) * zoom
        );

        // Margin
        var margin = radius + (radius / 3);
        origin.x -= margin;
        origin.y -= margin;

        // Transform
        origin.x = origin.x;
        origin.y = origin.y;

        // Translate
        origin.x += craft.pos.x;
        origin.y += craft.pos.y;

        // Padding
        var padding = radius / 8;
 
        // Background
        ctx.beginPath();
        ctx.fillStyle = "rgba(0,0,0,0.7)";
        ctx.arc(origin.x, origin.y, radius + padding, 0, 2*Math.PI);
        ctx.fill();

        // ctx.strokeStyle = "#000000";
        // ctx.lineWidth = 20;
        // ctx.stroke();
        
        // Direction ring
        ctx.beginPath();
        ctx.arc(origin.x, origin.y, radius, 0, 2*Math.PI);
        ctx.strokeStyle = "#FFFFFF";
        ctx.lineWidth = 2 * zoom;
        ctx.stroke();

        if (Math.abs(craft.velocity.x) > 0 || Math.abs(craft.velocity.y) > 0) {  
            var ratio = distance(0,0, craft.velocity.x, craft.velocity.y) / radius;
            var prograde = point(
                origin.x + craft.velocity.x / ratio,
                origin.y + craft.velocity.y / ratio
            );

            ctx.beginPath();
            ctx.fillStyle = "#FFFFFF";
            ctx.arc(prograde.x, prograde.y, padding / 2, 0, 2*Math.PI);
            ctx.fill();
        }

        var hudcraft = Object.assign({}, craft);
        hudcraft.pos = origin;
        hudcraft.size = Object.assign({}, craft.size);
        var newheight = radius;
        hudcraft.size.x = (hudcraft.size.x / hudcraft.size.y * newheight);
        hudcraft.size.y = newheight;

        draw_craft(hudcraft);

        ctx.restore();
    }

    function draw_planet(p) {
        ctx.save();

        var gradient = ctx.createRadialGradient(p.pos.x, p.pos.y, p.radius + 11000, p.pos.x, p.pos.y, p.radius + 100000);

        gradient.addColorStop(0, '#67AEFF');
        gradient.addColorStop(1, '#292929');
        ctx.fillStyle = gradient;
        var width = p.radius + 25000;
        ctx.fillRect(-2 * width,-2 * width,4 * width, 4 * width);
        

        ctx.beginPath();
        ctx.fillStyle = p.color;
        ctx.arc(p.pos.x, p.pos.y, p.radius, 0, 2*Math.PI);
        ctx.fill();

        if (draw_dashes) {
            // Draw surface of planet to give some sense of speed/scale
            ctx.beginPath();

            var circumfrence = 2 * Math.PI * p.radius;
            var dashes = 12000;
            var dash = circumfrence / dashes;

            ctx.setLineDash([dash,dash]);
            ctx.strokeStyle = "rgb(100,128,255)";
            ctx.lineWidth = 100;

            var relative_position = offset(p.pos.x, p.pos.y, craft.pos.x, craft.pos.y);

            var angle = Math.atan2(relative_position.y, relative_position.x);
            //console.log(angle);

            var section = Math.PI / 1280;
            var lockTo = 4 * Math.PI / dashes;


            ctx.arc(p.pos.x, p.pos.y, p.radius, roundTo(angle - section, lockTo), roundTo(angle + section, lockTo));

            ctx.stroke();
        }

        ctx.restore();
    }

    function draw_gate(g) {
        if (g == null)
            return;

        ctx.save();
        ctx.beginPath();

        ctx.strokeStyle = g.color;
        ctx.lineWidth = g.radius / 10;
        ctx.arc(g.pos.x, g.pos.y, g.radius, 0, 2*Math.PI);
        ctx.stroke();
        ctx.restore();
    }

    function relative_angle() {
        var rel_pos_polar = point_to_polar(planet.pos.x - craft.pos.x, planet.pos.y - craft.pos.y);
        var rel_angle = craft.attitude + Math.PI / 2 - rel_pos_polar.angle;

        return rel_angle;
    }

    function is_point_in_planet(pt, pl) {
        return distance(pt.x, pt.y, pl.pos.x, pl.pos.y) <= pl.radius;
    }

    function check_land() {

        var extra_length = Math.abs(craft.size.y / 2 * Math.cos(relative_angle()));
        var dist = distance(craft.pos.x, craft.pos.y, planet.pos.x, planet.pos.y) - extra_length;


        var rel_vel = distance(craft.velocity.x, craft.velocity.y, planet.velocity.x, planet.velocity.y);

        if (dist <= planet.radius) {
            craft.velocity = point(0, 0);    // stop the craft
            craft.rotational_velocity = 0;
            gravity_on = false;
        } else {
            gravity_on = true;
        }
    }

    function check_win() {
        if (gate == null)
        return false;

        if (distance(craft.pos.x, craft.pos.y, gate.pos.x, gate.pos.y) < gate.radius) {
            // Win!
            return true;
        }
        return false;
    }
</script>
</body></html>