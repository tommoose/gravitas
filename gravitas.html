<!--
    TODO: add clouds, fix drag model
-->
<html>
<head><meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
	
	<meta content="width=800, initial-scale=1" name="viewport" />
	<title></title>
	<script>
	</script>
</head>
<body>
<p><canvas id="canvas" style="margin: auto;"></canvas></p>

<div id="underlay" style="width: 100%; height: 100%; z-index: -1; position: absolute; top: 0; background-color: #292929"></div>
<script>
    var raf, running = false;
    var canvas = document.getElementById('canvas');
    var ctx = canvas.getContext('2d',{alpha: false});
    ctx.canvas.width  = document.getElementById("underlay").offsetWidth;
    ctx.canvas.height = document.getElementById("underlay").offsetHeight;

    function offset(x1, y1, x2, y2) {
        return point(x2-x1, y2-y1);
    }

    function distance(x1, y1, x2, y2) {
        return Math.sqrt(Math.abs(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)));
    }

    function centre(min_x, min_y, max_x, max_y) {
        return point(min_x + (max_x - min_x) / 2, min_y + (max_y - min_y) / 2);
    }

    function rotate_point(px, py, ox, oy, angle) {
        return point(
            Math.cos(angle) * (px - ox) - Math.sin(angle) * (py - oy) + ox,
            Math.sin(angle) * (px - ox) + Math.cos(angle) * (py - oy) + oy
        );
    }

    function roundTo(input, num) {
        var resto = input%num;
        if (resto <= (num/2)) { 
            return input-resto;
        } else {
            return input+num-resto;
        }
    }
    
    var point = function(x, y) {
        return {
            x: x,
            y: y
        }
    }

    var well = function(pos, g){
        return {
            pos: pos,
            g: g
        }
    };

    function start() {
        lastTime = new Date();
        running = true;
        animate();
    }

    document.addEventListener("keydown", function(e) {

        if (e.which == 71) {        // g
            gravity_on = !gravity_on;
            e.preventDefault();
        }
        else if (e.which == 13) {   // enter
            if (!running) {
                start();
            } else {
                // Reset
                reset();
            }
            e.preventDefault();
        }
        else if (e.which == 32) {   // space
            if (!running)
                start();
            craft.throttle = 100;
            e.preventDefault();
        }
        else if (e.which == 37) {   // left
            craft.rcs_throttle = -100;
            e.preventDefault();
        }
        else if (e.which == 39) {   // right
            craft.rcs_throttle = 100;
            e.preventDefault();
        }
        else if (e.which == 40) {   // down
            craft.rotational_velocity = 0;  // stability control
            e.preventDefault();
        } else if (e.which == 191) {  // question mark
            show_help = !show_help
            redraw();
            e.preventDefault();
        }
        else if (e.which == 90) {   // Z
            if (zoom == 1)
                zoom = 0.04;
            else
                zoom = 1;
            if (!running)
                redraw();
            e.preventDefault();
        }
        else if (e.which == 84) {   // Z
            trails_on = !trails_on;
            e.preventDefault();
        } else {    // everything else
            if (show_help)
                draw_message("Key" + e.which);
        }
        
    });

    document.addEventListener("keyup", function(e) {
        if (e.which == 32) { // space
            craft.throttle = 0;
            e.preventDefault();
        }
        else if (e.which == 37) {   //left
            craft.rcs_throttle = 0;
            e.preventDefault();
        }
        else if (e.which == 39) {   //right
            craft.rcs_throttle = 0;
            e.preventDefault();
        }
    });
		
    var lastTime, timeSinceLastFrame = 0;
    function animate() {
        if (running) {
            if (!check_win()) {
                redraw();
                raf = window.requestAnimationFrame(animate);
                var now = new Date();
                timeSinceLastFrame = now - lastTime;
                lastTime = now;
            } else {
                draw_win();
            }
        }
    }

    // particulars
    var craft, planet, gate;
    var gravity_on = true, trails_on = false;
    var show_help = false;
    var message = "", message_start = null, k_message_timeout = 3000;
    var zoom = 0.04;

    reset();

    function reset() {
        running = false;

        gravity_on = true;
        display_help = false;
        
        craft = setupCraft();
        planet = setupPlanet();
        //gate = setupGate();
        
        redraw();
    }

    function setupCraft() {
        return {
            pos: point(0, setupPlanet().radius * -1 - 100), 
            size: point(10,110),//point(30, 30),
            mass: 2970000,//100,
            dry_mass: 20,
            impulse: point(0,0),
            delta_vee: point(0,0),
            velocity: point(0,0),
            rotational_velocity: 0,
            rotation_velocity_max: 100,
            color: "rgb(255,255,255)",
            attitude: 0,
            throttle: 0,
            thrust: 36000000,//150000,
            rcs_throttle: 0,
            rcs_thrust: 30,
            drag_coefficient: 0.2,
            drag: point(0,0),
        }
    }

    function setupPlanet() {
        return {
            pos: point(0, 0), 
            g: 20,
            mass: 5.972 * Math.pow(10,24),
            velocity: point(0,0),
            radius: 6371000,
            color: "rgb(60,120,90)",
        }
    }

    function setupGate() {
        return {
            pos: point(ctx.canvas.width * 1 / 4, 0),
            radius: 30,
            mass: 0,
            impulse: point(0,0),
            delta_vee: point(0,0),
            velocity: point(0, 0),
            color: "rgb(40,40,255)",
        }
    }

    function redraw() {
        ctx.setTransform(1,0,0,1,0,0);//reset the transform matrix as it is cumulative
        if (!trails_on)
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);



        ctx.translate(ctx.canvas.width * 0.5, ctx.canvas.height * 0.5);
        ctx.transform(zoom, 0, 0, zoom, 0, 0 );

        if (!running)
            draw_title();

        if (show_help)
            draw_help();

        if (message != "" && (new Date() - message_start) <= k_message_timeout)
            draw_message();
        
        if (running) {
            if (gravity_on) {
                apply_gravity(craft, planet);
                if (gate != null)
                    apply_gravity(gate, planet);

            }


            apply_thrust(craft);
            apply_drag(craft);


            draw_stats();

            update_velocity(craft);
            check_land();

            apply_rcs(craft);
            update_rotational_velocity(craft);
        }

        ctx.translate(-1 * craft.pos.x, -1 * craft.pos.y);


        draw_planet(planet);
        draw_gate(gate);

        draw_craft();




    }

    function apply_gravity(obj, well) {
        var rel_pos = offset(obj.pos.x, obj.pos.y, well.pos.x, well.pos.y);

        var dist = Math.sqrt(Math.pow(rel_pos.x, 2) + Math.pow(rel_pos.y, 2));

        // F = G*((m sub 1*m sub 2)/r^2)
        var F = (6.67*Math.pow(10,-11)) * (obj.mass * well.mass) / Math.pow(dist, 2);
        //var dV = well.g / Math.pow(dist * 2, 2);

        //console.log(dist)
        if (F == 0)
            running = false;

        obj.impulse.x += F * rel_pos.x / dist;
        obj.impulse.y += F * rel_pos.y / dist;
    }

    function apply_thrust(c) {
        if (c.throttle > 0)
        {
            var thrust_x = c.thrust * Math.cos((c.attitude + 90) * Math.PI / 180) * c.throttle / 100;
            var thrust_y = c.thrust * Math.sin((c.attitude + 90) * Math.PI / 180) * c.throttle / 100;
            
            //console.log("Thrust: " + thrust_x + ", " + thrust_y);

            // atmosphere


            c.impulse.x -= thrust_x;
            c.impulse.y -= thrust_y;
        }
    }

    function apply_drag(c) {
        
        //var h = distance(c.pos.x, c.pos.y, planet.pos.x, planet.pos.y) - planet.radius * 0.3048; // to feet

        var T;
        var atmos = get_atmosphere(c);

        var drag_x = c.drag_coefficient * c.size.x * .5 * atmos.density * Math.pow(c.velocity.x, 2);
        var drag_y = c.drag_coefficient * c.size.x * .5 * atmos.density * Math.pow(c.velocity.y, 2);

        c = point(drag_x, drag_y);
    }

    function get_atmosphere(c) {
        var h = distance(c.pos.x, c.pos.y, planet.pos.x, planet.pos.y) - planet.radius; // in meters
        //var f = h * 3.2808399; // to feet
        var atmos = {
            zone: 0,
            altitude: h,
            temperature: 0,
            pressure: 0,
            density: 0,
            };


        if (h <= 11000) {
            // Troposphere
            atmos.zone = 0;
            atmos.temperature = 15.04 - 0.00649 * h;
            atmos.pressure = 101.29 * Math.pow((atmos.temperature + 273.1) / 288.08, 5.256);
        } else if (h < 25000) {
            // Lower stratosphere
            atmos.zone = 1;
            atmos.temperature = -56.46;
            atmos.pressure = 22.65 * Math.exp(1.73 - 0.000157 * h);
        } else {
            // Upper stratosphere
            atmos.zone = 2;
            atmos.temperature = -131.21 + 0.00299 * h;
            atmos.pressure = 2.488 * Math.pow((atmos.temperature + 273.1) / 216.6, -11.388);
        }

        atmos.density = atmos.pressure / (0.2869 * (atmos.temperature + 273.1));

        return atmos;
    }

    function apply_rcs(c) {
        if (c.rcs_throttle != 0)
        {
            c.rotational_velocity += c.rcs_thrust / c.mass * c.rcs_throttle / 100;
            if (Math.abs(c.rotational_velocity) > c.rotation_velocity_max)
                c.rotational_velocity = c.rotation_velocity_max * (c.rotational_velocity / Math.abs(c.rotational_velocity));
        }
    }

    function update_velocity(obj) {
        // drag (N)
        if (obj.velocity.x > 0)
            obj.impulse.x -= Math.abs(obj.drag.x);
        else 
            obj.impulse.x += Math.abs(obj.drag.x);

        if (obj.velocity.y > 0)
            obj.impulse.y -= Math.abs(obj.drag.y);
        else 
            obj.impulse.y += Math.abs(obj.drag.y);

        // a (m/s/s)
        var a_x = obj.impulse.x / obj.mass;
        var a_y = obj.impulse.y / obj.mass;

        // v (m/s) = v + a * t
        obj.velocity.x += a_x * timeSinceLastFrame / 1000;
        obj.velocity.y += a_y * timeSinceLastFrame / 1000;
        
        // pos (m) = v * t
        var d_x = obj.velocity.x * timeSinceLastFrame / 1000;
        var d_y = obj.velocity.y * timeSinceLastFrame / 1000;

        obj.impulse = point(0,0);

        obj.pos.x += d_x;
        obj.pos.y += d_y;
    }

    function update_rotational_velocity() {
        craft.attitude += craft.rotational_velocity * timeSinceLastFrame / 1000;
    }

    function draw_craft() {

        ctx.beginPath();

        var width = craft.size.x;
        var height = craft.size.y;

        var points = [];
        
        points.push(point(Math.floor(craft.pos.x - width / 2), Math.floor(craft.pos.y - height / 2)));  // NW
        
        points.push(point(Math.floor(craft.pos.x),Math.floor(craft.pos.y - height)));   // N
        
        points.push(point(Math.floor(craft.pos.x + width / 2),Math.floor(craft.pos.y - height / 2)));   // NE
        points.push(point(Math.floor(craft.pos.x + width / 2),Math.floor(craft.pos.y + height / 2)));   // SE

        if (craft.throttle > 0)
        {
            points.push(point(Math.floor(craft.pos.x + width * 2 / 6),Math.floor(craft.pos.y + height)));       // Flames 1 outer
            points.push(point(Math.floor(craft.pos.x + width * 1 / 6),Math.floor(craft.pos.y + height / 2)));   // Flames 2 inner
            points.push(point(Math.floor(craft.pos.x                ),Math.floor(craft.pos.y + height)));       // Flames 3 outer
            points.push(point(Math.floor(craft.pos.x - width * 1 / 6),Math.floor(craft.pos.y + height / 2)));   // Flames 4 inner
            points.push(point(Math.floor(craft.pos.x - width * 2 / 6),Math.floor(craft.pos.y + height)));       // Flames 5 outer
        }

        points.push(point(Math.floor(craft.pos.x - width / 2),Math.floor(craft.pos.y + height / 2)));   // SW

        // attitude
        for (var i = 0; i < points.length; i++) {
            var p = points[i],
                newpoint = rotate_point(p.x, p.y, craft.pos.x, craft.pos.y, (craft.attitude * Math.PI / 180));
            //points[i] = newpoint;
            
            // draw points
            if (i == 0)
                ctx.moveTo(newpoint.x, newpoint.y);
            else
                ctx.lineTo(newpoint.x, newpoint.y);
        }

        

        ctx.fillStyle = craft.color;
        ctx.fill();
    }

    function draw_title() {
        var center = point(ctx.canvas.width / 2 / zoom, ctx.canvas.height / 4 / zoom);

        ctx.save();
        ctx.fillStyle = "#ffffff";
        ctx.textAlign = "center";
        ctx.font = "bold " + 48 / zoom + "px Garamond, georgia, serif";
        ctx.fillText("Gravitas", 0, 18 / zoom);
        ctx.font = 28 / zoom + "px Garamond, georgia, serif";
        ctx.fillText("Press [Space] to Start", 0, 86 / zoom);
        ctx.font = 18 / zoom + "px Garamond, georgia, serif";
        ctx.fillText("Press [?] for options", 0, 116 / zoom);
        ctx.restore();
    }

    function draw_help() {
        ctx.save();
        ctx.fillStyle = "#ffffff";
        ctx.textAlign = "left";
        ctx.font = 14 / zoom + "px monospace";
        var line = 0, origin = point(-1 * canvas.width / 2 / zoom, -1 * canvas.height / 2 / zoom), offset = 10 / zoom, gap = 20 / zoom;
        ctx.fillText("[?]       Toggle help", origin.x + offset, origin.y + offset + (line++ * gap));
        ctx.fillText("[Enter]   Start/Reset", origin.x + offset, origin.y + offset + (line++ * gap));
        ctx.fillText("[g]       Toggle gravity", origin.x + offset, origin.y + offset + (line++ * gap));
        ctx.fillText("[<--/-->] Turn", origin.x + offset, origin.y + offset + (line++ * gap));
        ctx.fillText("[Down]    Stop rotation", origin.x + offset, origin.y + offset + (line++ * gap));
        ctx.fillText("[Space]   Thrust", origin.x + offset, origin.y + offset + (line++ * gap));
        ctx.restore();
    }

    function draw_win() {
        ctx.save();
        ctx.fillStyle = "#ffffff";
        ctx.textAlign = "center";
        ctx.font = "bold " + 48 / zoom + "px Garamond, georgia, serif";
        ctx.fillText("WIN!", craft.pos.x, craft.pos.y + craft.size.y * 1.5);
        ctx.restore();
    }

    function draw_message(msg) {
        if (msg == null)
            msg = message;
        else {
            message_start = new Date();
            message = msg;
        }

        ctx.save();
        ctx.fillStyle = "#ffffff";
        ctx.textAlign = "center";
        ctx.font = "bold " + 14 / zoom + "px Garamond, georgia, serif";
        ctx.fillText(msg, ctx.canvas.width / 2 / zoom, 10 / zoom);
        ctx.restore();
    }

    function draw_stats() {
        var atmos = get_atmosphere(craft);

        ctx.save();
        ctx.fillStyle = "#ffffff";
        ctx.textAlign = "right";
        ctx.font = "bold " + 14 / zoom + "px monospace";

        var 
        i = 0,
        x = (ctx.canvas.width / 2 - 30) / zoom, 
        y = -1 * (ctx.canvas.height / 2 - 10) / zoom,//craft.pos.y// / zoom,//-1 * zcanvas.width / 2 / zoom, 
        gap = 20 / zoom;

        ctx.fillText("Mass: " + roundTo(craft.mass, 1) + "kg", x, y + i++ * gap);

        ctx.fillText("Altitude: " + roundTo(atmos.altitude, 1) + "m", x, y + i++ * gap);
        ctx.fillText("Zone: " + atmos.zone, x, y + i++ * gap);
        ctx.fillText("Pressure: " + roundTo(atmos.pressure, 1) + "KPa", x, y + i++ * gap);
        ctx.fillText("Density: " + roundTo(atmos.density, 1) + "kg/m3", x, y + i++ * gap);

        ctx.fillText("X: " + roundTo(craft.pos.x, 1) + "m", x, y + i++ * gap);
        ctx.fillText("Y: " + roundTo(craft.pos.y, 1) + "m", x, y + i++ * gap);

        ctx.fillText("Fx: " + roundTo(craft.impulse.x, 1) + "N", x, y + i++ * gap);
        ctx.fillText("Fy: " + roundTo(craft.impulse.y, 1) + "N", x, y + i++ * gap);

        ctx.fillText("Vx: " + roundTo(craft.velocity.x, 1) + "m/s", x, y + i++ * gap);
        ctx.fillText("Vy: " + roundTo(craft.velocity.y, 1) + "m/s", x, y + i++ * gap);

        ctx.fillText("Dx: " + roundTo(craft.drag.x, 1) + "N", x, y + i++ * gap);
        ctx.fillText("Dy: " + roundTo(craft.drag.y, 1) + "N", x, y + i++ * gap);

        ctx.restore();
    }

    function draw_planet(p) {
        ctx.save();
        ctx.beginPath();

        ctx.fillStyle = p.color;
        ctx.arc(p.pos.x, p.pos.y, p.radius, 0, 2*Math.PI);
        ctx.fill();

        // Draw surface of planet to give some sense of speed/scale
        ctx.beginPath();

        var circumfrence = 2 * Math.PI * p.radius;
        var dashes = 12000;
        var dash = circumfrence / dashes;

        ctx.setLineDash([dash,dash]);
        ctx.strokeStyle = "rgb(100,128,255)";
        ctx.lineWidth = 100;

        var relative_position = offset(p.pos.x, p.pos.y, craft.pos.x, craft.pos.y);

        var angle = Math.atan2(relative_position.y, relative_position.x);
        //console.log(angle);

        var section = Math.PI / 1280;
        var lockTo = 4 * Math.PI / dashes;


        ctx.arc(p.pos.x, p.pos.y, p.radius, roundTo(angle - section, lockTo), roundTo(angle + section, lockTo));

        ctx.stroke();

        ctx.restore();
    }

    function draw_gate(g) {
        if (g == null)
            return;

        ctx.save();
        ctx.beginPath();

        ctx.strokeStyle = g.color;
        ctx.lineWidth = g.radius / 10;
        ctx.arc(g.pos.x, g.pos.y, g.radius, 0, 2*Math.PI);
        ctx.stroke();
        ctx.restore();
    }

    function check_land() {
        var dist = distance(craft.pos.x, craft.pos.y, planet.pos.x, planet.pos.y);
        var rel_vel = distance(craft.velocity.x, craft.velocity.y, planet.velocity.x, planet.velocity.y);

        if (dist <= planet.radius && rel_vel < 100000) {
            craft.velocity = point(0,0);    // stop the craft
            craft.rotational_velocity = 0;
            gravity_on = false;
        } else {
            gravity_on = true;
        }

    }

    function check_win() {
        if (gate == null)
        return false;

        if (distance(craft.pos.x, craft.pos.y, gate.pos.x, gate.pos.y) < gate.radius) {
            // Win!
            return true;
        }
        return false;
    }
</script>
</body></html>